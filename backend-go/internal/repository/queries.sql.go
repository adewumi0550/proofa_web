// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package repository

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	"github.com/pgvector/pgvector-go"
)

const addItemToCollection = `-- name: AddItemToCollection :exec
INSERT INTO collection_items (collection_id, project_id)
VALUES ($1, $2)
`

type AddItemToCollectionParams struct {
	CollectionID pgtype.UUID
	ProjectID    pgtype.UUID
}

func (q *Queries) AddItemToCollection(ctx context.Context, arg AddItemToCollectionParams) error {
	_, err := q.db.Exec(ctx, addItemToCollection, arg.CollectionID, arg.ProjectID)
	return err
}

const createAuthorshipCertification = `-- name: CreateAuthorshipCertification :one

INSERT INTO authorship_certifications (project_id, collection_id, user_id, certification_hash, pqc_signature, audit_data)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, project_id, collection_id, user_id, certification_hash, pqc_signature, audit_data, created_at
`

type CreateAuthorshipCertificationParams struct {
	ProjectID         pgtype.UUID
	CollectionID      pgtype.UUID
	UserID            pgtype.UUID
	CertificationHash string
	PqcSignature      string
	AuditData         []byte
}

// Certification-related queries
func (q *Queries) CreateAuthorshipCertification(ctx context.Context, arg CreateAuthorshipCertificationParams) (AuthorshipCertification, error) {
	row := q.db.QueryRow(ctx, createAuthorshipCertification,
		arg.ProjectID,
		arg.CollectionID,
		arg.UserID,
		arg.CertificationHash,
		arg.PqcSignature,
		arg.AuditData,
	)
	var i AuthorshipCertification
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CollectionID,
		&i.UserID,
		&i.CertificationHash,
		&i.PqcSignature,
		&i.AuditData,
		&i.CreatedAt,
	)
	return i, err
}

const createCollection = `-- name: CreateCollection :one

INSERT INTO collections (user_id, name, description)
VALUES ($1, $2, $3)
RETURNING id, user_id, name, description, created_at
`

type CreateCollectionParams struct {
	UserID      pgtype.UUID
	Name        string
	Description pgtype.Text
}

// Collection-related queries
func (q *Queries) CreateCollection(ctx context.Context, arg CreateCollectionParams) (Collection, error) {
	row := q.db.QueryRow(ctx, createCollection, arg.UserID, arg.Name, arg.Description)
	var i Collection
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createCreativeSeed = `-- name: CreateCreativeSeed :one
INSERT INTO creative_seeds (user_id, content, embedding, metadata)
VALUES ($1, $2, $3, $4)
RETURNING id, user_id, content, embedding, metadata, created_at
`

type CreateCreativeSeedParams struct {
	UserID    pgtype.UUID
	Content   string
	Embedding pgvector.Vector
	Metadata  []byte
}

func (q *Queries) CreateCreativeSeed(ctx context.Context, arg CreateCreativeSeedParams) (CreativeSeed, error) {
	row := q.db.QueryRow(ctx, createCreativeSeed,
		arg.UserID,
		arg.Content,
		arg.Embedding,
		arg.Metadata,
	)
	var i CreativeSeed
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Content,
		&i.Embedding,
		&i.Metadata,
		&i.CreatedAt,
	)
	return i, err
}

const createEvidenceLog = `-- name: CreateEvidenceLog :one
INSERT INTO evidence_logs (user_id, prompt, seed_id, human_score, reasoning, evidence_hash, pqc_signature)
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, prompt, seed_id, human_score, reasoning, evidence_hash, pqc_signature, created_at
`

type CreateEvidenceLogParams struct {
	UserID       pgtype.UUID
	Prompt       string
	SeedID       pgtype.UUID
	HumanScore   float64
	Reasoning    pgtype.Text
	EvidenceHash string
	PqcSignature string
}

func (q *Queries) CreateEvidenceLog(ctx context.Context, arg CreateEvidenceLogParams) (EvidenceLog, error) {
	row := q.db.QueryRow(ctx, createEvidenceLog,
		arg.UserID,
		arg.Prompt,
		arg.SeedID,
		arg.HumanScore,
		arg.Reasoning,
		arg.EvidenceHash,
		arg.PqcSignature,
	)
	var i EvidenceLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Prompt,
		&i.SeedID,
		&i.HumanScore,
		&i.Reasoning,
		&i.EvidenceHash,
		&i.PqcSignature,
		&i.CreatedAt,
	)
	return i, err
}

const createProject = `-- name: CreateProject :one

INSERT INTO projects (user_id, seed_text, embedding, plagiarism_score, ai_probability, status)
VALUES ($1, $2, $3, $4, $5, $6)
RETURNING id, user_id, seed_text, embedding, plagiarism_score, ai_probability, status, created_at
`

type CreateProjectParams struct {
	UserID          pgtype.UUID
	SeedText        string
	Embedding       pgvector.Vector
	PlagiarismScore pgtype.Float8
	AiProbability   pgtype.Float8
	Status          string
}

// Project-related queries
func (q *Queries) CreateProject(ctx context.Context, arg CreateProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, createProject,
		arg.UserID,
		arg.SeedText,
		arg.Embedding,
		arg.PlagiarismScore,
		arg.AiProbability,
		arg.Status,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeedText,
		&i.Embedding,
		&i.PlagiarismScore,
		&i.AiProbability,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (email, firebase_uid, pqc_public_key, pqc_private_key_encrypted)
VALUES ($1, $2, $3, $4)
RETURNING id, email, firebase_uid, pqc_public_key, pqc_private_key_encrypted, created_at
`

type CreateUserParams struct {
	Email                  string
	FirebaseUid            string
	PqcPublicKey           string
	PqcPrivateKeyEncrypted string
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.FirebaseUid,
		arg.PqcPublicKey,
		arg.PqcPrivateKeyEncrypted,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirebaseUid,
		&i.PqcPublicKey,
		&i.PqcPrivateKeyEncrypted,
		&i.CreatedAt,
	)
	return i, err
}

const getCertificationByProject = `-- name: GetCertificationByProject :one
SELECT id, project_id, collection_id, user_id, certification_hash, pqc_signature, audit_data, created_at FROM authorship_certifications WHERE project_id = $1
`

func (q *Queries) GetCertificationByProject(ctx context.Context, projectID pgtype.UUID) (AuthorshipCertification, error) {
	row := q.db.QueryRow(ctx, getCertificationByProject, projectID)
	var i AuthorshipCertification
	err := row.Scan(
		&i.ID,
		&i.ProjectID,
		&i.CollectionID,
		&i.UserID,
		&i.CertificationHash,
		&i.PqcSignature,
		&i.AuditData,
		&i.CreatedAt,
	)
	return i, err
}

const getCollectionItems = `-- name: GetCollectionItems :many
SELECT p.id, p.user_id, p.seed_text, p.embedding, p.plagiarism_score, p.ai_probability, p.status, p.created_at FROM projects p
JOIN collection_items ci ON p.id = ci.project_id
WHERE ci.collection_id = $1
`

func (q *Queries) GetCollectionItems(ctx context.Context, collectionID pgtype.UUID) ([]Project, error) {
	rows, err := q.db.Query(ctx, getCollectionItems, collectionID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeedText,
			&i.Embedding,
			&i.PlagiarismScore,
			&i.AiProbability,
			&i.Status,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEvidenceLog = `-- name: GetEvidenceLog :one
SELECT id, user_id, prompt, seed_id, human_score, reasoning, evidence_hash, pqc_signature, created_at FROM evidence_logs WHERE id = $1
`

func (q *Queries) GetEvidenceLog(ctx context.Context, id pgtype.UUID) (EvidenceLog, error) {
	row := q.db.QueryRow(ctx, getEvidenceLog, id)
	var i EvidenceLog
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Prompt,
		&i.SeedID,
		&i.HumanScore,
		&i.Reasoning,
		&i.EvidenceHash,
		&i.PqcSignature,
		&i.CreatedAt,
	)
	return i, err
}

const getEvidenceLogsBySeed = `-- name: GetEvidenceLogsBySeed :many
SELECT prompt FROM evidence_logs
WHERE seed_id = $1
ORDER BY created_at ASC
`

func (q *Queries) GetEvidenceLogsBySeed(ctx context.Context, seedID pgtype.UUID) ([]string, error) {
	rows, err := q.db.Query(ctx, getEvidenceLogsBySeed, seedID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var prompt string
		if err := rows.Scan(&prompt); err != nil {
			return nil, err
		}
		items = append(items, prompt)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByFirebaseUID = `-- name: GetUserByFirebaseUID :one
SELECT id, email, firebase_uid, pqc_public_key, pqc_private_key_encrypted, created_at FROM users WHERE firebase_uid = $1
`

func (q *Queries) GetUserByFirebaseUID(ctx context.Context, firebaseUid string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByFirebaseUID, firebaseUid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirebaseUid,
		&i.PqcPublicKey,
		&i.PqcPrivateKeyEncrypted,
		&i.CreatedAt,
	)
	return i, err
}

const getUserCollections = `-- name: GetUserCollections :many
SELECT id, user_id, name, description, created_at FROM collections WHERE user_id = $1
`

func (q *Queries) GetUserCollections(ctx context.Context, userID pgtype.UUID) ([]Collection, error) {
	rows, err := q.db.Query(ctx, getUserCollections, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Collection
	for rows.Next() {
		var i Collection
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchCreativeSeeds = `-- name: SearchCreativeSeeds :many
SELECT id, user_id, content, embedding, metadata, created_at, (1 - (embedding <=> $2))::float8 AS similarity
FROM creative_seeds
WHERE user_id = $1
ORDER BY similarity DESC
LIMIT $3
`

type SearchCreativeSeedsParams struct {
	UserID    pgtype.UUID
	Embedding pgvector.Vector
	Limit     int32
}

type SearchCreativeSeedsRow struct {
	ID         pgtype.UUID
	UserID     pgtype.UUID
	Content    string
	Embedding  pgvector.Vector
	Metadata   []byte
	CreatedAt  pgtype.Timestamptz
	Similarity float64
}

func (q *Queries) SearchCreativeSeeds(ctx context.Context, arg SearchCreativeSeedsParams) ([]SearchCreativeSeedsRow, error) {
	rows, err := q.db.Query(ctx, searchCreativeSeeds, arg.UserID, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchCreativeSeedsRow
	for rows.Next() {
		var i SearchCreativeSeedsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Content,
			&i.Embedding,
			&i.Metadata,
			&i.CreatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchProjects = `-- name: SearchProjects :many
SELECT id, user_id, seed_text, embedding, plagiarism_score, ai_probability, status, created_at, (1 - (embedding <=> $2))::float8 AS similarity
FROM projects
WHERE user_id = $1
ORDER BY similarity DESC
LIMIT $3
`

type SearchProjectsParams struct {
	UserID    pgtype.UUID
	Embedding pgvector.Vector
	Limit     int32
}

type SearchProjectsRow struct {
	ID              pgtype.UUID
	UserID          pgtype.UUID
	SeedText        string
	Embedding       pgvector.Vector
	PlagiarismScore pgtype.Float8
	AiProbability   pgtype.Float8
	Status          string
	CreatedAt       pgtype.Timestamptz
	Similarity      float64
}

func (q *Queries) SearchProjects(ctx context.Context, arg SearchProjectsParams) ([]SearchProjectsRow, error) {
	rows, err := q.db.Query(ctx, searchProjects, arg.UserID, arg.Embedding, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SearchProjectsRow
	for rows.Next() {
		var i SearchProjectsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.SeedText,
			&i.Embedding,
			&i.PlagiarismScore,
			&i.AiProbability,
			&i.Status,
			&i.CreatedAt,
			&i.Similarity,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateProjectStatus = `-- name: UpdateProjectStatus :one
UPDATE projects
SET status = $2, plagiarism_score = $3, ai_probability = $4
WHERE id = $1
RETURNING id, user_id, seed_text, embedding, plagiarism_score, ai_probability, status, created_at
`

type UpdateProjectStatusParams struct {
	ID              pgtype.UUID
	Status          string
	PlagiarismScore pgtype.Float8
	AiProbability   pgtype.Float8
}

func (q *Queries) UpdateProjectStatus(ctx context.Context, arg UpdateProjectStatusParams) (Project, error) {
	row := q.db.QueryRow(ctx, updateProjectStatus,
		arg.ID,
		arg.Status,
		arg.PlagiarismScore,
		arg.AiProbability,
	)
	var i Project
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.SeedText,
		&i.Embedding,
		&i.PlagiarismScore,
		&i.AiProbability,
		&i.Status,
		&i.CreatedAt,
	)
	return i, err
}
